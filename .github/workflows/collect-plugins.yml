name: Collect Plugin Information

on:
  workflow_dispatch:
  schedule:
    - cron: '0 2 * * *'

jobs:
  collect-plugins:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.PAT_TOKEN }}

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Install dependencies
      run: |
        npm init -y
        npm install @octokit/rest

    - name: Collect plugin information
      id: collect
      env:
        PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
      run: |
        node <<'NODE'
        const fs = require('fs');

        (async function main() {
          const { Octokit } = await import('@octokit/rest');

          const octokit = new Octokit({
            auth: process.env.PAT_TOKEN,
            userAgent: 'AstrBot Plugin Collector v1.0',
            baseUrl: 'https://api.github.com',
          });

          try {
            console.log('Fetching issues with plugin-publish label from astrbotdevs/astrbot...');
            let page = 1;
            let allIssues = [];
            while (true) {
              const { data } = await octokit.rest.issues.listForRepo({
                owner: 'astrbotdevs',
                repo: 'astrbot',
                labels: 'plugin-publish',
                state: 'open',
                per_page: 100,
                page
              });
              if (!data.length) break;
              allIssues = allIssues.concat(data);
              console.log('Fetched page', page, '- found', data.length, 'issues');
              page++;
            }

            console.log('Total found', allIssues.length, 'issues with plugin-publish label');

            const plugins = [];
            const codeBlockRegex = /```(?:json)?\s*([\s\S]*?)\s*```/i;

            for (const issue of allIssues) {
              console.log('Processing issue #' + issue.number + ':', issue.title);
              const body = issue.body || '';
              const jsonMatch = body.match(codeBlockRegex);
              if (jsonMatch) {
                try {
                  const jsonStr = jsonMatch[1].trim();
                  const pluginInfo = JSON.parse(jsonStr);
                  if (pluginInfo.name && pluginInfo.desc && pluginInfo.author && pluginInfo.repo) {
                    pluginInfo.issue_number = issue.number;
                    pluginInfo.issue_url = issue.html_url;
                    pluginInfo.created_at = issue.created_at;
                    pluginInfo.updated_at = issue.updated_at;
                    if (!pluginInfo.tags) pluginInfo.tags = [];
                    if (!pluginInfo.social_link) pluginInfo.social_link = '';
                    plugins.push(pluginInfo);
                    console.log('âœ“ Extracted plugin:', pluginInfo.name);
                  } else {
                    console.log('âœ— Missing required fields in issue #' + issue.number);
                  }
                } catch (parseError) {
                  console.log('âœ— Failed to parse JSON in issue #' + issue.number + ':', parseError.message);
                }
              } else {
                console.log('âœ— No JSON block found in issue #' + issue.number);
              }
            }

            const result = {
              updated_at: new Date().toISOString(),
              total_plugins: plugins.length,
              plugins: plugins.sort((a, b) => a.name.localeCompare(b.name))
            };

            // å†™åˆ°ä»“åº“æ ¹ç›®å½• plugin-issue.json
            fs.writeFileSync('plugin-issue.json', JSON.stringify(result, null, 2));
            console.log('âœ“ Created plugin-issue.json with', plugins.length, 'plugins');

            if (process.env.GITHUB_OUTPUT) {
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `plugins_count=${plugins.length}\n`);
            } else {
              console.log(`plugins_count=${plugins.length}`);
            }
          } catch (error) {
            console.error('Error:', error);
            process.exit(1);
          }
        })();
        NODE

    - name: Stage file and Check for changes (handles new file case)
      id: check_changes
      run: |
        # stage the generated file (ensures new/untracked files are considered)
        git add plugin-issue.json || true

        # If there are staged changes compared to HEAD, exit code will be non-zero
        if git diff --staged --quiet --exit-code; then
          echo "has_changes=false" >> $GITHUB_OUTPUT
          echo "No changes detected (no staged changes)"
        else
          echo "has_changes=true" >> $GITHUB_OUTPUT
          echo "Staged changes detected"
        fi

    - name: Commit and push changes
      if: steps.check_changes.outputs.has_changes == 'true'
      run: |
        git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        git add plugin-issue.json
        git commit -m "ðŸ”„ Update plugin-issue.json - ${{ steps.collect.outputs.plugins_count }} plugins collected" || echo "No changes to commit"
        git push

    - name: Create summary
      if: always()
      run: |
        echo "## Plugin Collection Summary" >> $GITHUB_STEP_SUMMARY
        echo "- **Total plugins collected:** ${{ steps.collect.outputs.plugins_count }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Changes detected:** ${{ steps.check_changes.outputs.has_changes }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Timestamp:** $(date --iso-8601=seconds)" >> $GITHUB_STEP_SUMMARY

        if [ -f "plugin-issue.json" ]; then
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Latest plugin-issue.json preview:" >> $GITHUB_STEP_SUMMARY
          echo '```json' >> $GITHUB_STEP_SUMMARY
          head -40 plugin-issue.json >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
        fi
